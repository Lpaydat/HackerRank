object Solution {
    
  def sumsOfPowers(limit: Int, power: Int): Int = {
    def candidates(limit: Int, n: Int = 1): List[Int] = {
      def powers(n: Int, power: Int): Int = if (power == 0) 1 else n * powers(n, power - 1)
      val powered = powers(n, power)
      if (powered > limit) Nil
      else powered :: candidates(limit, n + 1)
    }
    
    // create a list with all possibilities
    def grouping(candidates: List[Int], set: List[List[Int]] = List(List(0))): List[List[Int]] = {
      if (candidates.isEmpty || set.isEmpty) List(List())
      else {
        val newSet = for {
          head <- candidates
          cList <- set
          if cList.sum + head <= limit && cList.max < head
        } yield head :: cList
        newSet ::: grouping(candidates.tail, newSet)
      }
    }
    
    grouping(candidates(limit)).count(_.sum == limit)
  }

  def main(args: Array[String]) {
     println(sumsOfPowers(readInt(),readInt()))
  }
}
